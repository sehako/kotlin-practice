package part02.chapter13.section1

// DSL은 도메인 특화 언어(Domain-Specific Language)를 의미한다. 이 목표는 궁극적으로는 코드 가독성과 유지보수성 향상이다.
// 클래스는 대부분 다른 클래스와 상호작용한다. 따라서 클래스의 API를 잘 만들어야 하는 책임은
// 라이브러리나 프레임워크 개발자를 포함해서 모든 개발자에게 존재한다. 조직에서도 내가 만든 클래스를 다른 사람이 쓸 수 있기 때문이다.
// API를 잘 만든다는 의미는 다음과 같다.
/*
- 코드를 읽는 독자가 어떤 일이 벌어지는지 정확하게 이해할 수 있어야 한다.
- 코드에 불필요한 구문이나 번잡한 준비 코드가 가능한 한 적어야 한다.
 */
// 코틀린은 확장 함수, 중위 함수 노출, 람다에 사용할 수 있는 it 등의 문법적 편의, 연산자 오버로딩 등이 있다.
// 여기에 더 나아가서 DSL을 통해 API에 비해서 더욱 더 깔끔한 코드를 만들 수 있다.

// 그렇다면 DSL이 무엇일까? 그동안 범용 프로그래밍 언어와
// 특정 도메인에 초점을 맞추고 그 영역에 필요하지 않은 기능을 없앤 도메인 특화 언어를 구분해왔다.
// 가장 익숙한 DSL은 SQL이다. 이는 데이터베이스 관련 작업에 특화된 언어다.
// 따라서 전체 애플리케이션을 SQL로 작성하지는 않는다.

// 또한 이런 DSL이 범용 프로그래밍 언어와 다르게 더 선언적이라는 점이 중요하다.
// 범용 프로그래밍 언어는 명령적인데, 이는 어떤 연산을 완수하기 위해 필요한 각 단계를 순서대로 정확히 기술한다.
// 반면 선언적 언어는 원하는 결과를 기술하기만 하고 그 결과를 달성하기 위한 필요한 세부 실행은 언어를 해석하는 엔진에 맡긴다.

// 물론 DSL에는 이러한 장점을 넘어서는 큰 단점이 있는데, 범용 언어로 개발한 애플리케이션과 DSL을 함께 조합하기가 어렵다는 것이다.
// 자체 문법이 있기 때문에 다른 언어의 프로그램에서 직접 포함시킬 수 없기 때문이다.
// 따라서 최근에는 언어나 라이브러리에서 내부적으로 DSL을 제공하는 경우가 있다. (StreamAPI, 코틀린 gradle의존관계 정의, QueryDSL 등)

// API에 비해 DSL에만 존재하는 특징이 구조 또는 문법이다.
// 전형적인 라이브러리는 여러 메서드로 이루어지며 클라이언트는 그런 메서드를 하나씩 호출한다. (명령-질의)
// 반대로 DSL의 메서드 호출은 일반적으로 람다를 내포시키거나 메서드 호출을 연쇄시키는 방식으로 구조를 만든다.
// 따라서 API에 비해 좀 더 선언적으로 질의를 수행할 수 있다.
// gradle 의존관계 정의 코드를 보면 좀 더 명확히 보여진다.
/*
dependencies {
    testImplementation(kotlin("test"))
    implementation(kotlin("reflect"))
}
 */
// 이를 명령-질의 API를 통해 같은 일을 한다면 수 add() 메서드를 중복해서 호출해야 할 것이다.

