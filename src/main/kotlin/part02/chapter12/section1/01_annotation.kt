package part02.chapter12.section1

// 어노테이션을 사용하면 선언에 추가적인 메타데이터를 연관시킬 수 있다.
// 그 후 어노테이션이 설정된 방식에 따라 메타데이터를 소스코드, 컴파일된 클래스 파일, 런타임에 대해 작동하는 도구를 통해 접근할 수 있다.
// 자바와 마찬가지로 어노테이션은 @로 선언할 수 있다.

// @Deprecated 어노테이션은 현재 함수가 이제 더 이상 사용되지 않을 것이라는 경고를 표시하기 위해 사용된다.
@Deprecated("Use removeAt(index) instead.", ReplaceWith("removeAt(index)"))
fun remove(index: Int) {
}
// 어노테이션의 인자로는 가본 타입의 값, 문자열, enum, 클래스 참조, 다른 어노테이션 클래스, 이들의 배열이 쓰일 수 있다.
// 어노테이션 인자는 컴파일 시점에 알 수 있어야 하므로 임의의 프로퍼티를 인자로 지정할 수는 없다.
// 따라서 프로퍼티를 어노테이션 인자로 사용하려면 const 변경자를 명시해야 한다.

// 소스코드에서 한 선언을 컴파일한 결과가 여러 자바 선언과 대응하는 경우가 자주 있다.
// 이때 코틀린 선언과 대응하는 여러 자바 선언에 각각 어노테이션을 선언해야 할 때가 있다.
// 그 예로, 코틀린 프로퍼티는 기본적으로 자바 필드, getter, 필요하다면 setter 및 그 파라미터 선언과 대응한다.
// 또한 주 생성자에서 프로퍼티를 선언하면 이런 접근자 메서드와 파라미터 외에 자바 생성자 파라미터와도 대응된다.

// 쉽게 말해서 코틀린은 간단한 코드 한 줄로 여러 요소들을 내부적으로 만들어주는데,
// 이때 어노테이션을 선언했을 때 어느 코드에 대응되는지 알 수 없다는 것이다.
// 이를 사용 지점 타깃 선언을 통해 어노테이션을 붙일 요소를 정할 수 있다.
// @기호와 어노테이션 이름 사이에 붙으며 어노테이션 이름과는 콜론(:)으로 분리된다.
// @get:JvmName("obtainCertificate") <- 프로퍼티 getter에 JvmName 어노테이션을 적용하라는 의미
// 참고로 @JvmName은 자바에서 호출할 이름을 지정할 수 있는 어노테이션이다.
class CertificateManager {
    @get:JvmName("obtainCertificate")
    @set:JvmName("putCertificate")
    var certificate: String = "----BEGIN PRIVATE KEY----"
}
// 사용 지점 타깃 지정할 때 지원하는 타깃 목록은 다음과 같다.
/*
- property: 프로퍼티 전체
- field: 프로퍼티 의해 생성되는 필드
- get: 프로퍼티 getter
- set: 프로퍼티 setter
- receiver: 확장 함수나 프로퍼티의 수신 객체 프로퍼티
- param: 생성자 파라미터
- setparam: setter 파라미터
- delegate: 위임 프로퍼티의 위임 인스턴스를 담아둔 필드
- file: 파일 안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스
참고로 file 대상을 사용하는 어노테이션은 파일에서 package 선언보다 더 앞에만 넣을 수 있다.
 */

/*
또한 코틀린은 코틀린으로 선언한 내용을 자바 바이트코드로 컴파일하는 방법과 코틀린 선언을
자바에 노출하는 방법을 제어하기 위한 어노테이션을 많이 제공한다. 이런 어노테이션 중 일부는 자바 언어의 일부 키워드를 대신한다.

- @JvmName: 코틀린 선언이 만들어내는 자바 필드나 메서드 이름을 변경한다.
- @JvmStatic: 객체 선언이나 동반 객체의 메서드에 적용하면 메서드가 자바 정적 메서드로 노출된다.
- @JvmOverloads: 디폴트 파라미터 값이 있는 함수에 대해 컴파일러가 자동으로 오버로딩한 함수를 생성해준다.
- @JvmField: 프로퍼티에 사용하면 대상 프로퍼티를 getter나 setter가 없는 공개된 자바 필드로 노출시킨다.
- @JvmRecord: data class에 사용하면 자바 레코드 클래스를 선언할 수 있다.
 */
