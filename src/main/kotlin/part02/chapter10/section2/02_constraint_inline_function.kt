package part02.chapter10.section2

// 람다를 사용하는 모든 함수를 인라이닝할 수는 없다.
// 함수가 인라이닝될 때 그 함수에 인자로 전달된 람다식의 본문은 결과 코드에 직접 들어갈 수 있다.
// 하지만 람다를 변수에 저장하고 나중에 그 변수를 사용하면 람다를 표현하는 객체가 어딘가에는 존재해야 하므로 인라이닝할 수 없다.
class FunctionStorage {
    var myStoredFunction: ((Int) -> Unit)? = null
    inline fun storeFunction(f: (Int) -> Unit) {
        // 전달된 파라미터를 저장한다. 따라서 컴파일러는 모든 호출 지점에서 이 코드를 대치할 수 없으므로
        // 인라인 파라미터 f를 잘못 사용한다는 오류를 보고한다.
//        myStoredFunction = f
    }
    // 인라인 함수의 본문에서 람다식을 바로 호출하거나 다른 인라인 함수의 인자로 전달하는 경우에는
    // 인라이닝이 가능하지만 그런 경우가 아니라면 컴파일러는 인라이닝을 금지시킨다.
    // 정리하자면 인라인 함수는 다른 함수로 전달하거나 또는 전달 받아서 바로 실행하는 것만 허용한다는 의미다.
    // 그 외에 위 상황처럼 변수로 저장되는 경우에는 익명 클래스 인스턴스로 만들 수밖에 없다.
}

// 둘 이상의 람다를 인자로 받는 함수에서 일부 람다만 인라이닝을 금지해야 한다면
// noinline 변경자로 인라이닝을 금지할 수 있다.
inline fun noInlineExample(inlined: () -> Unit, noinline notInlined: () -> Unit) {

}

// 컴파일러는 모듈이나 서드파티 라이브러리 안에서 정의된 인라인 함수도 지원하며,
// 코틀린에서 정의한 인라인 함수를 자바에서 호출할 수 있다. (이 경우 컴파일러에서 인라인 함수를 인라이닝하지 않고 일반 함수 호출로 컴파일 한다.)
