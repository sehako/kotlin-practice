package chapter14

import kotlin.concurrent.thread

// 동시성: 여러 작업을 동시에 실행되는 것 처럼 보이게 만드는 것, 따라서 싱글 코어에서의 교차 실행도 동시성으로 본다.
// 병렬성: 여러 작업을 여러 CPU 코어에서 물리적으로 동시에 실행
// 코틀린은 코루틴을 통해 비동기 논블로킹 동시성 코드를 작성할 수 있다.

// 스레드 vs 코루틴
// 코틀린도 자바에서처럼 스레드를 사용할 수 있다.
fun threadExample() {
    println("I'm on thread ${Thread.currentThread().name}")
    // thread 함수를 통한 스레드 시작 후 작업 실행 예시
    thread {
        println("And I'm on thread ${Thread.currentThread().name}")
    }
}
// JVM 스레드는 운영체제가 관리하는 스레드로, 시스템 스레드는 관리 비용이 많이 든다. (메모리 할당, 커널 수준의 문맥 교환)
// 또한 작업 완료를 대기하려면 결국 블록을 시켜야 하며, 취소나 예외 처리 같은 관리도 굉장히 제한적이다.

// 코틀린은 스레드에 대한 대안으로 코루틴을 도입했다. 다음과 같은 특징이 있다.
// - 초경량: 노트북에서도 100,000개 이상의 코루틴을 실행할 수 있고, 생성 및 관리 비용이 저렴하다.
// - 논블로킹: 시스템 자원을 블록시키지 않으며, 실행을 중단 및 재개시킬 수 있다.
// - 구조화된 동시성(structured concurrency): 작업의 구조와 계층을 확립하여 취소 및 오류 처리를 위한 방법을 제공한다.

/*
코루틴과 프로젝트 룸(loom)
JVM에 가상 스레드 형태의 경량 동시성을 도입하는 프로젝트이다.
주요 목표는 기존의 I/O 중심 레거시 코드를 가상 스레드로 포팅할 수 있게 하는 것이다.
이는 룸의 장점이자 약점으로, 기존의 자바 스레드와 I/O API에 맞춰 재구성되었기 때문에
로컬 계산과 대기 작업에 대한 언어 수준의 구분이 없어 대규모 코드에서 코드 이해가 난해하다.
또한 자바 스레드는 비용이 많이 들지만, 코루틴은 비용이 매우 적어 새로운 코루틴을 지속적으로 생성해도 문제가 없다.
그리고 구조화된 동시성으로 인해 코틀린 코루틴은 잠재적 자원 누수를 방지하게 만들어져 있기도 하다.
그래도 룸이 제공하는 새로운 기능을 활용할 수도 있다. (ex. 코루틴에 룸 기반의 가상 스레드 디스패치를 제공)
 */
