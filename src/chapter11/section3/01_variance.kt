package chapter11.section3

// 직접 제네릭 클래스나 함수를 정의하는 경우 변성을 꼭 이해해야 한다.
// List<Anty> 타입의 파라미터를 받는 함수에 List<String>을 넘기는 경우를 살펴보자.
fun addAnswer(list: MutableList<Any>) {
    list.add(10)
}

fun addAnswerWithVariance() {
    val strings = mutableListOf<String>("abc")
//    addAnswer(strings) // 이 부분에서 컴파일 오류가 발생한다.
    strings.maxBy { it.length }
}

// 코틀린 컴파일러는 위와 같은 상황을 허용하지 않는다.
// 즉 List<Any>에 List<String>을 넘겼을 때 어떤 원소의 변경 로직이 있으면
// 타입 불일치가 생길 수 있어서 안전하지 않다. (반대로 원소의 변경 로직이 없으면 안전하다)

// 이를 이해하기 위해서는 먼저 하위 타입(subtype) 개념을 살펴봐야 한다.
// 타입과 클래스는 혼용되지만 엄밀히 말하면 다르다. 모든 코틀린 클래스는 null 여부에 따라서 둘 이상의 타입을 구성할 수 있다.
// 제네릭 클래스에서 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 명시해야 한다.
// 따라서 List는 타입이 아니지만 List<Int>, List<String?>은 모두 제대로 된 타입이다.

// 그리고 타입은 관계를 가진다. A 타입의 값이 필요한 곳에 B 타입의 값을 넣어도 문제가 없다면 B는 A의 하위 타입이다.
// 상위타입은 하위 타입의 반대로 여기서 A는 B의 상위 타입이다. 이를 다음과 같이 표현한다. (B -> A)
// 이것이 중요한 이유는 컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행하기 때문이다.
fun test(i: Int) {
    val n: Number = i // Int가 Number의 하위 타입이어서 컴파일된다.

    fun f(s: String) {}
//    f(i) <- Int가 String의 하위 타입이 아니어서 컴파일 오류가 발생한다.
}
// 하위 타입은 하위 클래스와 근본적으로 같다. 따라서 어떤 클래스나 인터페이스를 상속하거나 구현하면 타입 간의 관계가 생기게 된다.
// 참고로 null이 될 수 있는 타입은 좀 다르다. A -> A?는 가능하지만 A? -> A는 불가능하다.

// 제네릭 타입에서 하위 클래스와 하위 타입의 차이가 중요해진다.
// List<Any>를 List<String> 타입의 값을 전달해도 괜찮은가?는 곧 List<String>은 List<Any>의 하위 타입인가?이다.
// 어떤 제네릭 타입에 대해서 서로 다른 두 타입 A와 B에 대해 MutableList<A>가 항상 MutableList<B>의
// 하위 타입도 아니고 상위 타입도 아닌 경우에 제네릭 타입이 타입 파라미터에 대해 무공변이라고 한다.
// 반대로 A가 B의 하위 타입이면 List<A>는 List<B>의 하위 타입인 클래스나 인터페이스를 공변적이라고 한다.
// 참고로 자바에서는 모든 클래스가 무공변이다.
